<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Doodle Hide Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    background: #eee;
    touch-action: none;
    user-select: none;
  }
  canvas {
    display: block;
    margin: auto;
    background: #fafafa;
  }
</style>
</head>
<body>

<canvas id="game" width="800" height="500"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ===== 壁 =====
const walls = [
  { x: 300, y: 80, w: 200, h: 20 },
  { x: 300, y: 400, w: 200, h: 20 },
  { x: 200, y: 180, w: 20, h: 140 },
  { x: 580, y: 180, w: 20, h: 140 }
];

// ===== プレイヤー =====
const player = {
  x: 120,
  y: 250,
  r: 8,
  speed: 2.2
};

// ===== 鬼 =====
const oni = {
  x: 650,
  y: 250,
  dir: 0,
  speed: 1.4,
  viewAngle: Math.PI / 3,
  viewDist: 180,
  target: null,
  seeTime: 0
};

// ===== アイテム =====
const item = {
  x: 400,
  y: 150,
  r: 6
};

let score = 0;
let gameOver = false;
let keys = {};

// ===== 仮想スティック =====
let joystick = {
  active: false,
  startX: 0,
  startY: 0,
  dx: 0,
  dy: 0,
  radius: 60
};

// ===== ユーティリティ =====
const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

function randomTarget() {
  return {
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height
  };
}

// ===== 壁衝突判定（円 vs 矩形）=====
function hitWall(x, y, r) {
  for (const w of walls) {
    const nx = Math.max(w.x, Math.min(x, w.x + w.w));
    const ny = Math.max(w.y, Math.min(y, w.y + w.h));
    if (Math.hypot(x - nx, y - ny) < r) return true;
  }
  return false;
}

// ===== キーボード =====
addEventListener("keydown", e => keys[e.key] = true);
addEventListener("keyup", e => keys[e.key] = false);

// ===== タッチ =====
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  const y = t.clientY - rect.top;

  if (x < canvas.width / 2) {
    joystick.active = true;
    joystick.startX = x;
    joystick.startY = y;
    joystick.dx = 0;
    joystick.dy = 0;
  } else {
    oni.target = { x, y };
  }
});

canvas.addEventListener("touchmove", e => {
  if (!joystick.active) return;
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  const y = t.clientY - rect.top;

  joystick.dx = x - joystick.startX;
  joystick.dy = y - joystick.startY;

  const len = Math.hypot(joystick.dx, joystick.dy);
  if (len > joystick.radius) {
    joystick.dx *= joystick.radius / len;
    joystick.dy *= joystick.radius / len;
  }
});

canvas.addEventListener("touchend", () => {
  joystick.active = false;
  joystick.dx = 0;
  joystick.dy = 0;
});

// ===== 更新 =====
function update() {
  if (gameOver) return;

  // --- プレイヤー移動 ---
  let vx = 0, vy = 0;
  if (keys["ArrowUp"]) vy -= 1;
  if (keys["ArrowDown"]) vy += 1;
  if (keys["ArrowLeft"]) vx -= 1;
  if (keys["ArrowRight"]) vx += 1;

  if (joystick.active) {
    vx += joystick.dx / joystick.radius;
    vy += joystick.dy / joystick.radius;
  }

  const len = Math.hypot(vx, vy);
  if (len > 0) {
    const nx = player.x + (vx / len) * player.speed;
    const ny = player.y + (vy / len) * player.speed;
    if (!hitWall(nx, ny, player.r)) {
      player.x = nx;
      player.y = ny;
    }
  }

  // --- 鬼移動 ---
  if (!oni.target) oni.target = randomTarget();

  const dx = oni.target.x - oni.x;
  const dy = oni.target.y - oni.y;
  const d = Math.hypot(dx, dy);

  oni.dir = Math.atan2(dy, dx);
  const nx = oni.x + Math.cos(oni.dir) * oni.speed;
  const ny = oni.y + Math.sin(oni.dir) * oni.speed;

  if (!hitWall(nx, ny, 10)) {
    oni.x = nx;
    oni.y = ny;
  } else {
    oni.target = null;
  }

  if (d < 6) oni.target = null;

  // --- 視界判定 ---
  const ang = Math.atan2(player.y - oni.y, player.x - oni.x);
  let diff = Math.abs(((ang - oni.dir + Math.PI * 3) % (Math.PI * 2)) - Math.PI);

  if (dist(player, oni) < oni.viewDist && diff < oni.viewAngle / 2) {
    oni.seeTime += 1 / 60;
    if (oni.seeTime > 1.2) gameOver = true;
  } else {
    oni.seeTime = 0;
  }

  // --- アイテム ---
  if (dist(player, item) < player.r + item.r) {
    score++;
    item.x = 200 + Math.random() * 400;
    item.y = 100 + Math.random() * 300;
  }
}

// ===== 描画 =====
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 壁
  ctx.fillStyle = "#444";
  walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

  // アイテム
  ctx.fillStyle = "gold";
  ctx.beginPath();
  ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
  ctx.fill();

  // 鬼視界
  ctx.fillStyle = "rgba(255,0,0,0.2)";
  ctx.beginPath();
  ctx.moveTo(oni.x, oni.y);
  ctx.arc(
    oni.x, oni.y,
    oni.viewDist,
    oni.dir - oni.viewAngle / 2,
    oni.dir + oni.viewAngle / 2
  );
  ctx.closePath();
  ctx.fill();

  // 鬼
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(oni.x, oni.y, 10, 0, Math.PI * 2);
  ctx.fill();

  // プレイヤー
  ctx.fillStyle = "blue";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();

  // UI
  ctx.fillStyle = "#000";
  ctx.font = "16px sans-serif";
  ctx.fillText("Score: " + score, 10, 20);

  if (gameOver) {
    ctx.font = "32px sans-serif";
    ctx.fillText("GAME OVER", canvas.width / 2 - 90, canvas.height / 2);
  }

  // スティック
  if (joystick.active) {
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(joystick.startX, joystick.startY, joystick.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(
      joystick.startX + joystick.dx,
      joystick.startY + joystick.dy,
      15, 0, Math.PI * 2
    );
    ctx.stroke();
  }
}

// ===== ループ =====
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
