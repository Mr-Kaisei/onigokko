<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Doodle Hide Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    background: #eee;
    touch-action: none;
    user-select: none;
  }
  canvas {
    display: block;
    margin: auto;
    background: #fafafa;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = 800;
canvas.height = 500;

// ===== 壁 =====
const walls = [
  { x: 260, y: 140, w: 280, h: 20 },
  { x: 260, y: 340, w: 280, h: 20 },
  { x: 260, y: 140, w: 20, h: 220 },
  { x: 520, y: 140, w: 20, h: 90 },
  { x: 520, y: 270, w: 20, h: 90 }
];

// ===== プレイヤー =====
const player = { x: 120, y: 250, r: 8, speed: 2.2 };

// ===== 鬼 =====
const oni = {
  x: 650,
  y: 250,
  dir: 0,
  speed: 1.4,
  viewAngle: Math.PI / 3,
  viewDist: 180,
  target: null,
  seeTime: 0
};

// ===== アイテム =====
const item = { x: 400, y: 250, r: 6 };

let score = 0;
let gameOver = false;
let keys = {};

// ===== スティック =====
let joystick = {
  active: false,
  startX: 0,
  startY: 0,
  dx: 0,
  dy: 0,
  radius: 60
};

// ===== 共通 =====
const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

function randomTarget() {
  return {
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height
  };
}

// ===== 壁当たり判定 =====
function hitWall(x, y, r) {
  for (const w of walls) {
    const nx = Math.max(w.x, Math.min(x, w.x + w.w));
    const ny = Math.max(w.y, Math.min(y, w.y + w.h));
    if (Math.hypot(x - nx, y - ny) < r) return true;
  }
  return false;
}

// ===== レイが壁に当たる距離 =====
function rayDistance(ax, ay, angle, maxDist) {
  for (let d = 0; d < maxDist; d += 4) {
    const x = ax + Math.cos(angle) * d;
    const y = ay + Math.sin(angle) * d;
    for (const w of walls) {
      if (
        x > w.x &&
        x < w.x + w.w &&
        y > w.y &&
        y < w.y + w.h
      ) {
        return d;
      }
    }
  }
  return maxDist;
}

// ===== 入力 =====
addEventListener("keydown", e => keys[e.key] = true);
addEventListener("keyup", e => keys[e.key] = false);

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  const y = t.clientY - rect.top;

  if (x < canvas.width / 2) {
    joystick.active = true;
    joystick.startX = x;
    joystick.startY = y;
  } else {
    oni.target = { x, y };
  }
});

canvas.addEventListener("touchmove", e => {
  if (!joystick.active) return;
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  joystick.dx = t.clientX - rect.left - joystick.startX;
  joystick.dy = t.clientY - rect.top - joystick.startY;

  const len = Math.hypot(joystick.dx, joystick.dy);
  if (len > joystick.radius) {
    joystick.dx *= joystick.radius / len;
    joystick.dy *= joystick.radius / len;
  }
});

canvas.addEventListener("touchend", () => {
  joystick.active = false;
  joystick.dx = joystick.dy = 0;
});

// ===== 更新 =====
function update() {
  if (gameOver) return;

  let vx = 0, vy = 0;
  if (keys["ArrowUp"]) vy--;
  if (keys["ArrowDown"]) vy++;
  if (keys["ArrowLeft"]) vx--;
  if (keys["ArrowRight"]) vx++;

  if (joystick.active) {
    vx += joystick.dx / joystick.radius;
    vy += joystick.dy / joystick.radius;
  }

  const len = Math.hypot(vx, vy);
  if (len > 0) {
    const nx = player.x + (vx / len) * player.speed;
    const ny = player.y + (vy / len) * player.speed;
    if (!hitWall(nx, ny, player.r)) {
      player.x = nx;
      player.y = ny;
    }
  }

  if (!oni.target) oni.target = randomTarget();
  const dx = oni.target.x - oni.x;
  const dy = oni.target.y - oni.y;
  const d = Math.hypot(dx, dy);

  oni.dir = Math.atan2(dy, dx);
  const ox = oni.x + Math.cos(oni.dir) * oni.speed;
  const oy = oni.y + Math.sin(oni.dir) * oni.speed;

  if (!hitWall(ox, oy, 10)) {
    oni.x = ox;
    oni.y = oy;
  } else {
    oni.target = null;
  }

  if (d < 6) oni.target = null;

  // 見つかり判定（壁考慮）
  const ang = Math.atan2(player.y - oni.y, player.x - oni.x);
  const diff = Math.abs(((ang - oni.dir + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
  const rayDist = rayDistance(oni.x, oni.y, ang, oni.viewDist);

  const canSee =
    diff < oni.viewAngle / 2 &&
    dist(player, oni) < rayDist;

  if (canSee) {
    oni.seeTime += 1 / 60;
    if (oni.seeTime > 1.2) gameOver = true;
  } else {
    oni.seeTime = 0;
  }

  if (dist(player, item) < player.r + item.r) {
    score++;
    item.x = 350 + Math.random() * 100;
    item.y = 200 + Math.random() * 100;
  }
}

// ===== 描画 =====
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 壁
  ctx.fillStyle = "#000";
  walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

  // 視界（壁で止まる）
  ctx.fillStyle = "rgba(255,0,0,0.25)";
  ctx.beginPath();
  ctx.moveTo(oni.x, oni.y);
  for (let a = -oni.viewAngle / 2; a <= oni.viewAngle / 2; a += 0.05) {
    const ang = oni.dir + a;
    const d = rayDistance(oni.x, oni.y, ang, oni.viewDist);
    ctx.lineTo(
      oni.x + Math.cos(ang) * d,
      oni.y + Math.sin(ang) * d
    );
  }
  ctx.closePath();
  ctx.fill();

  // 鬼
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(oni.x, oni.y, 10, 0, Math.PI * 2);
  ctx.fill();

  // プレイヤー
  ctx.fillStyle = "blue";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();

  // アイテム
  ctx.fillStyle = "gold";
  ctx.beginPath();
  ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#000";
  ctx.fillText("Score: " + score, 10, 20);

  if (gameOver) {
    ctx.font = "32px sans-serif";
    ctx.fillText("GAME OVER", 330, 260);
  }

  if (joystick.active) {
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath();
    ctx.arc(joystick.startX, joystick.startY, joystick.radius, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
